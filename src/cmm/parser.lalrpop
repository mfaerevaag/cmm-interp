use std::str::FromStr;
use ast::*;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, (usize, &'input str), ()>>);


// macros

Comma<T>: Vec<T> = {
    <h:(<T> ",")*> <t:T?> =>
        h.into_iter().chain(t).collect()
};

// token precedence

match {
    "return",
    "extern",
    "if",
    "else",
    "while",
    "for",
    "continue",
    "break",

    "void",
    "int",
    "char",

    "printf",

} else {
    r"[0-9]+" => TInt,
    r#""\w*""# => TString,
    r#"('(.|([\\]0|([\\]n)))')"# => TChar,

} else {
    r"[a-zA-Z][a-zA-Z0-9_]*" => TIdent,

    _
}

// production rules

pub Prog: CProg<'input> = <l:(<ProgElem>)*> => {
    l.into_iter().flat_map(|x| x.to_vec()).collect()
};

ProgElem: Vec<CProgElem<'input>> = {
    // decl
    <t:Type> <m:VarArray> <r:("," <VarArray>)*> ";" => {
        vec![m].into_iter().chain(r).map(|(id, s)| {
            CProgElem::Decl(t.clone(), id, s)
        }).collect()
    },

    // proto
    Proto,

    // func
    Func => vec![CProgElem::Func(<>)],
};

Proto: Vec<CProgElem<'input>> = {
    "void" <m:Comma<FuncDecl>> ";" => {
        m.into_iter().map(|(id, ps)| {
            CProgElem::Proto(CProto {
                ret: None,
                name: id,
                params: ps,
            })
        }).collect()
    },
    <l:Type> <m:Comma<FuncDecl>> ";" => {
        m.into_iter().map(|(id, ps)| {
            CProgElem::Proto(CProto {
                ret: Some(l.clone()),
                name: id,
                params: ps,
            })
        }).collect()
    },
};

pub Func: CFunc<'input> = {
    "void" <r:FuncDecl> "{"
        <stmt:(<Stmt>)*> "}" =>
    {
        let (id, param) = r;
        CFunc {
            proto: CProto {
                ret: None,
                name: id,
                params: param,
            },
            stmts: stmt.into_iter().flat_map(|x| match x {
                CStmt::Block(_, ss) => {
                    ss.into_iter().map(|b| *b).collect()
                },
                x => vec![x]
            }).collect(),
        }
    },
    <l:Type> <r:FuncDecl> "{"
        <stmt:(<Stmt>)*> "}" =>
    {
        let (id, param) = r;
        CFunc {
            proto: CProto {
                ret: Some(l),
                name: id,
                params: param,
            },
            stmts: stmt.into_iter().flat_map(|x| match x {
                CStmt::Block(_, ss) => {
                    ss.into_iter().map(|b| *b).collect()
                },
                x => vec![x]
            }).collect(),
        }
    },
};

FuncDecl: (CIdent<'input>, Vec<(CType, CIdent<'input>)>) = {
    <id:Ident> "(" <param:FuncParam> ")" => (id, param),
};

FuncParam: Vec<(CType, CIdent<'input>)> = {
    Comma<Param>,
    "void" => Vec::new(),
};

Param: (CType, CIdent<'input>) = {
    <t:Type> <r:Ident> <s:("[" "]")*> => {
        let mut tt = t;
        for i in 0..s.len() {
            tt = CType::Ref(Box::new(tt));
        }
        (tt, r)
    }
};

// statements

pub Stmt: CStmt<'input> = {
    Stmt_ => *<>,
};

Stmt_: Box<CStmt<'input>> = {
    StmtIfMatching,
    StmtIfUnmatching,
};

StmtIfMatching: Box<CStmt<'input>> = {
    <l:@L> "if" "(" <cond:Expr> ")" <stmt:StmtIfMatching> "else" <stmt2:StmtIfMatching> <r:@R> =>
        Box::new(CStmt::If((l, r), cond, stmt, Some(stmt2))),
    StmtOther,
};

StmtIfUnmatching: Box<CStmt<'input>> = {
    <l:@L> "if" "(" <cond:Expr> ")" <stmt:StmtIfMatching> <r:@R> =>
        Box::new(CStmt::If((l, r), cond, stmt, None)),
    <l:@L> "if" "(" <cond:Expr> ")" <stmt:StmtIfMatching> "else" <stmt2:StmtIfUnmatching> <r:@R> =>
        Box::new(CStmt::If((l, r), cond, stmt, Some(stmt2))),
};

StmtOther: Box<CStmt<'input>> = {
    // decl
    <StmtDecl> ";",

    // assignment
    <StmtAssign> ";",

    // return
    <l:@L> "return" <e:Expr> ";" <r:@R> =>
        Box::new(CStmt::Return((l, r), Some(e))),
    <l:@L> "return" ";" <r:@R> =>
        Box::new(CStmt::Return((l, r), None)),

    // block
    <l:@L> "{" <s:(<Stmt_>)*> "}" <r:@R> =>
        Box::new(CStmt::Block((l, r), s)),

    // while
    <l:@L> "while" "(" <cond:Expr> ")" <stmt:StmtIfMatching> <r:@R> =>
        Box::new(CStmt::While((l, r), cond, stmt)),

    // for
    <l:@L> "for" "(" <init:StmtAssign?> ";" <cond:Expr?> ";" <inc:StmtAssign?> ")" <stmt:StmtIfMatching> <r:@R> => {
        let mut top = vec![];
        match init {
            Some(s) => top.push(s),
            None => {}
        };

        let cond = match cond {
            Some(e) => e,
            // TODO: fix booleans...
            None => CExpr::LogOp(COp::Eq, Box::new(CExpr::Num(1)), Box::new(CExpr::Num(1))),
        };

        let body = match inc {
            Some(s) => {
                let mut ss = vec![];
                match *stmt {
                    CStmt::Block(_, s) => {
                        ss.extend(s);
                    },
                    _ => ss.push(stmt),
                };
                ss.push(s);
                Box::new(CStmt::Block((0,0), ss))
            },
            None => stmt,
        };

        // TODO: fix locations
        let whiles = CStmt::While((l, r), cond, body);

        top.push(Box::new(whiles));

        Box::new(CStmt::Block((l, r), top))
    },

    // print
    <l:@L> "printf" "(" <e:Expr> ")" ";" <r:@R> =>
        Box::new(CStmt::Print((l, r), e)),

    // error
    // ! => { errors.push(<>); Box::new(CStmt::Error) },
};

StmtDecl: Box<CStmt<'input>> = {
    <l:@L> <t:Type> <m:Comma<StmtDecl2>> <r:@R> => {
        let mut x: Vec<Box<CStmt<'input>>> = m.into_iter().map(|(id, s, eo)| {
            let mut ss = vec![];

            ss.push(Box::new(CStmt::Decl((l, r), t.clone(), id, s)));
            // also init?
            if let Some(e) = eo {
                ss.push(Box::new(CStmt::Assign((l, r), id, s, e)));
            }

            ss
        }).flat_map(|x| x.to_vec()).collect(); // flatten

        match x.len() {
            1 => x.pop().unwrap(),
            _ => Box::new(CStmt::Block((l, r), x))
        }
    },
};

StmtDecl2: (CIdent<'input>, Option<usize>, Option<CExpr<'input>>) = {
    <l:Ident> <so:("[" <Size> "]")?> <eo:("=" <Expr>)?> => (l, so, eo),
};

VarArray: (CIdent<'input>, Option<usize>) = {
    <l:Ident> "[" <r:TInt> "]" => (l, Some(usize::from_str(r).unwrap())),
    Ident => (<>, None),
};

StmtAssign: Box<CStmt<'input>> = {
    <l:@L> <i:VarArray> "=" <e:Expr> <r:@R> => {
        let (id, s) = i;
        Box::new(CStmt::Assign((l, r), id, s, e))
    }
};

// expression

pub Expr: CExpr<'input> = {
    Expr1 => *<>,
};

Expr1: Box<CExpr<'input>> = {
    <l:Expr1> "||" <r:Expr2> => Box::new(CExpr::LogOp(COp::Or, l, r)),
    Expr2,
};

Expr2: Box<CExpr<'input>> = {
    <l:Expr2> "&&" <r:Expr3> => Box::new(CExpr::LogOp(COp::And, l, r)),
    Expr3,
};

Expr3: Box<CExpr<'input>> = {
    <l:Expr3> <op:ExprOpRel2> <r:Expr4> => Box::new(CExpr::RelOp(op, l, r)),
    Expr4,
};

Expr4: Box<CExpr<'input>> = {
    <l:Expr4> <op:ExprOpRel> <r:Expr5> => Box::new(CExpr::RelOp(op, l, r)),
    Expr5,
};

Expr5: Box<CExpr<'input>> = {
    <l:Expr5> <op:ExprOp> <r:Factor> => Box::new(CExpr::BinOp(op, l, r)),
    Factor,
};

Factor: Box<CExpr<'input>> = {
    <l:Factor> <op:FactorOp> <r:Term> => Box::new(CExpr::BinOp(op, l, r)),
    Term,
};

Term: Box<CExpr<'input>> = {
    Num => Box::new(CExpr::Num(<>)),
    Str => Box::new(CExpr::Str(<>)),
    Char => Box::new(CExpr::Char(<>)),

    // variable
    Ident => Box::new(CExpr::Ident(<>)),

    // unary op
    <op:TermOp> <r:Term> => Box::new(CExpr::UnOp(op, r)),

    // call
    <i:Ident> "(" <p:Comma<Expr1>> ")" => Box::new(CExpr::Call(i, p)),
    // array index
    <i:Ident> "[" <r:Expr1> "]" => Box::new(CExpr::Index(i, r)),

    "(" <Expr1> ")",

    // ! => { errors.push(<>); Box::new(CExpr::Error) },
};

ExprOp: COp = {
    "+" => COp::Add,
    "-" => COp::Sub,
};

ExprOpRel: COp = {
    "<" => COp::Lt,
    "<=" => COp::Lte,
    ">" => COp::Gt,
    ">=" => COp::Gte,
};

ExprOpRel2: COp = {
    "==" => COp::Eq,
    "!=" => COp::Neq,
};

ExprOpLog: COp = {
    "&&" => COp::And,
    "||" => COp::Or,
};

FactorOp: COp = {
    "*" => COp::Mul,
    "/" => COp::Div,
};

TermOp: COp = {
    "-" => COp::Neg,
    "!" => COp::Not,
};

// simple stuff

Num: CInt = {
    TInt => i32::from_str(<>).unwrap(),
};

Size: usize = {
    TInt => usize::from_str(<>).unwrap(),
};

Str: CString<'input> = {
    TString => <>.get(1..(<>.len() - 1)).unwrap().chars(),
};

Char: CChar = {
    TChar => match <> {
        "'\\0'" => '\0',
        "'\\n'" => '\n',
        _ => <>.chars().nth(1).unwrap(),
    }
};

Ident: &'input str = {
    TIdent => <>,
};

Type: CType = {
    "int" => CType::Int,
    "char" => CType::Char,
};
